# class Report(): # Этот класс будет помогать обрабатывать текстовые данные и выводить отчёты.
#     def __init__(self, title, content): # Создадим def init и пропишем, что у отчёта будет заголовок и контент:
#         self.title = title # Привяжем созданное к нашему классу:
#         self.content = content # Также привяжем к нашему классу:
#     def docPrint(self):
#         print(f"сформирован отчет {self.title} - {self.content}") # В итоге у нас получился обычный класс.
#         Теперь представим,что нам нужно его расширить: сделать так, чтобы он умел обрабатывать не только обычный текст, но и html.

# ИЗНАЧАЛЬНО была возможность работать только с текстовыми форматами.

# Теперь после создания абстрактного класса появилась возможность работать с HTML форматами и можно будет добавлять новые форматы
#
# Перепишем созданный класс с учётом принципа открытости/закрытости
# Теперь перепишем созданный класс так, чтобы его можно было самостоятельно дополнять новыми функциями — другими словами,
# используем метод открытости/закрытости.

from abc import ABC, abstractmethod  # Модуль для работы с абстрактными классами
# Перепишем созданный класс с учётом принципа открытости/закрытости
# Теперь перепишем созданный класс так, чтобы его можно было самостоятельно дополнять новыми функциями
# — другими словами, используем метод открытости/закрытости.
class Formatted(ABC):
    @abstractmethod # Это дополнения к функциям, "обёртки", у которых есть какой-то свой функционал, который добавляется в функцию, которую мы прописываем.
    # abstractmethod — это декоратор, который прописывается перед той функцией, к которой он будет применяться:
    def format(self, report): #Создадим функцию format и на следующей строке pass, чтобы не выдавалась ошибка:
        pass
# Только что мы создали абстрактный класс, внутри которого есть абстрактный метод, который сейчас полностью пустой. Это шаблон, и другие классы,
# которые мы будем создавать, будут от этого класса наследовать и будут переопределять этот метод по-своему, в зависимости от прописанных задач.
class TextFormatted(Formatted): # Создадим обычный класс, который работает с обычным текстом
# Дадим название классу TextFormatted, а в круглых скобках укажем название класса, от которого нужно наследовать, то есть уже не ABC, а Formatted:
    def format(self, report): # пропишем функцию “формат”
        print(f"Заголовок отчета {report.title}") # Функцию print мы пока не заполняем, поскольку у нас нет ни заголовка, ни контента. Заполним их чуть позже.
        print(f"Сформирован отчет {report.content}")
class HtmlFormatted(Formatted): #Создадим ещё один класс, который будет преобразовывать в формат html
    def format(self, report):
        print(f"<h1>Заголовок отчета {report.title} </h1>") # пример форматирования с помощью тегов <h1> </h1> заголовок тэгов
        print(f"<p>Сформирован отчет {report.content} </p>") # пример форматирования с помощью тегов <p> </p> параграф - обычный текст
class Report(): #Создадим последний, обычный класс
# В этот класс будет вноситься вся необходимая информация.
    def __init__(self, title, content, formated): # Пропишем характеристики: это заголовок, контент и формат того, как мы будем это всё обрабатывать:
# Сейчас у нас есть два класса: один обрабатывает текстовую информацию, другой — html. Нам нужно будет выбирать, что мы будем использовать,
# поэтому необходимо создать характеристику, которая будет обозначать нужный нам выбор. Прописываем привязку этих характеристик к созданному классу:
        self.title = title
        self.content = content
        self.formated = formated #здесь сохранится объект класса Formatted и через будет вызван метод format

# Нам необходимо вызвать функции print, которые находятся внутри функции format. Чтобы их использовать, к классу Report добавим ещё одну функцию: def docPrinter(self):
# Пропишем вызов функции format у ранее прописанной характеристики formatted, в которой сохранён объект класса.
# Объект класса у нас либо HtmlFormatted, либо TextFormatted. Через объект класса мы будем вызывать функцию format, либо текстовую, либо в формате html,
# в зависимости от того, что у нас сохранено в formatted. Мы прописываем: self.formatted.format()
    def docPrinter(self):
        self.formated.format(self)

# Создадим объект класса report, внеся информацию в заголовок и контент. Для этого пропишем: report = Report('заголовок отчета', 'это текст отчета, его тут много', TextFormatted())
# Прописав TextFormatted, мы тем самым указываем класс, который будет использоваться. Здесь будет создаваться объект класса, который будет сохраняться в Formatted.
# Прописанный нами report нужно будет использовать в классах TextFormatted и HtmlFormatted. Для этого сначала вернёмся к объекту print класса TextFormatted и в круглых скобках пропишем:
# print(report.title) print(report.content) Таким образом мы обозначили, что хотим вывести заголовок и контент.


report = Report("- Заголовок", "- это текст отчета, его тут много", TextFormatted())
#report = Report("- Заголовок", "- это текст отчета, его тут много", HtmlFormatted())
report.docPrinter()